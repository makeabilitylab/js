function t(t){return t*(Math.PI/180)}function n(t){return t*(180/Math.PI)}function i(t,n,i){return(1-i)*t+i*n}function r(t,n){void 0===n&&(n=t,t=0);const i=Math.min(t,n),r=Math.max(t,n);return Math.random()*(r-i)+i}class s{constructor(t,n){this.x=t,this.y=n}add(t){return new s(this.x+t.x,this.y+t.y)}subtract(t){return new s(this.x-t.x,this.y-t.y)}multiply(t){return new s(this.x*t,this.y*t)}divide(t){return new s(this.x/t,this.y/t)}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.magnitude();return 0===t?new s(0,0):new s(this.x/t,this.y/t)}dotProduct(t){return this.x*t.x+this.y*t.y}angleBetween(t){const n=this.dotProduct(t),i=this.magnitude()*t.magnitude();if(Math.abs(n-i)<Number.EPSILON)return n>=0?0:Math.PI;if(0===i)return 0;const r=n/i;let s=Math.acos(r);return this.x*t.y-this.y*t.x<0&&(s=2*Math.PI-s),s}toString(){return`(${this.x}, ${this.y})`}static fromPoints(t,n){return new s(n.x-t.x,n.y-t.y)}}export{s as Vector,n as convertToDegrees,t as convertToRadians,i as lerp,r as random};
