function t(t){return t*(Math.PI/180)}function n(t){return t*(180/Math.PI)}function r(t,n,r){return(1-r)*t+r*n}function i(t,n){return void 0===n&&(n=t,t=0),Math.random()*(n-t)+t}class s{constructor(t,n){this.x=t,this.y=n}add(t){return new s(this.x+t.x,this.y+t.y)}subtract(t){return new s(this.x-t.x,this.y-t.y)}multiply(t){return new s(this.x*t,this.y*t)}divide(t){return new s(this.x/t,this.y/t)}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.magnitude();return new s(this.x/t,this.y/t)}dotProduct(t){return this.x*t.x+this.y*t.y}angleBetween(t){const n=this.dotProduct(t),r=this.magnitude()*t.magnitude();if(Math.abs(n-r)<Number.EPSILON)return n>=0?0:Math.PI;if(0===r)return 0;const i=n/r;let s=Math.acos(i);return this.x*t.y-this.y*t.x<0&&(s=2*Math.PI-s),s}toString(){return`(${this.x}, ${this.y})`}static fromPoints(t,n){return new s(n.x-t.x,n.y-t.y)}}export{s as Vector,n as convertToDegrees,t as convertToRadians,r as lerp,i as random};
